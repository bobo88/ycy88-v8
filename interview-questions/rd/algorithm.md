# 算法篇

> TODO

## 1. **算法复杂度分析**

- **时间复杂度（Time Complexity）**：衡量算法执行时间随输入规模变化的增长率。常见的时间复杂度有 O(1), O(log n), O(n), O(n log n), O(n^2), O(2^n), O(n!) 等。
- **空间复杂度（Space Complexity）**：衡量算法所需的内存空间随输入规模变化的增长率。

## 2. **大 O 记号（Big O Notation）**

- 用于描述算法的时间复杂度和空间复杂度的上限，表示最坏情况的性能。

## 3. **递归（Recursion）**

- **定义**：函数直接或间接调用自身。
- **基本思想**：将问题分解为规模更小的子问题来解决。
- **基本组成部分**：基例（Base Case）和递归关系（Recursive Case）。

## 4. **动态规划（Dynamic Programming）**

- **定义**：将问题分解为子问题，通过保存子问题的解来避免重复计算。
- **适用场景**：有重叠子问题和最优子结构性质的问题。

## 5. **分治法（Divide and Conquer）**

- **定义**：将问题分解为独立的子问题，解决这些子问题，然后合并它们的解来解决原问题。
- **适用场景**：问题可以分解为多个独立的子问题。

## 6. **贪心算法（Greedy Algorithm）**

- **定义**：在每一步选择中都采取当前状态下的最优选择，从而希望能够导致全局最优解。
- **适用场景**：问题具有贪心选择性质和最优子结构性质。

## 7. **回溯算法（Backtracking）**

- **定义**：通过搜索所有可能的解来解决问题，当发现某个解不满足条件时，回溯并尝试其他可能的解。
- **适用场景**：问题需要搜索所有可能的解决方案。

## 8. **图算法（Graph Algorithms）**

- **深度优先搜索（DFS）**：遍历图的一个分支，直到不能继续，然后回溯并探索其他分支。
- **广度优先搜索（BFS）**：逐层遍历图中的节点。
- **最短路径算法**：如 Dijkstra 算法、Bellman-Ford 算法。
- **最小生成树算法**：如 Prim 算法、Kruskal 算法。

## 9. **排序算法（Sorting Algorithms）**

- **冒泡排序（Bubble Sort）**：O(n^2)
- **选择排序（Selection Sort）**：O(n^2)
- **插入排序（Insertion Sort）**：O(n^2)
- **快速排序（Quick Sort）**：平均 O(n log n)
- **归并排序（Merge Sort）**：O(n log n)
- **堆排序（Heap Sort）**：O(n log n)

## 10. **查找算法（Search Algorithms）**

- **线性查找（Linear Search）**：O(n)
- **二分查找（Binary Search）**：O(log n)

## 11. **树和二叉树（Trees and Binary Trees）**

- **树的基本概念**：根节点、叶节点、子节点、父节点。
- **二叉树遍历**：前序遍历、中序遍历、后序遍历。
- **二叉搜索树（BST）**：具有特定性质的二叉树，左子树所有节点的值小于根节点的值，右子树所有节点的值大于根节点的值。

## 12. **哈希表（Hash Table）**

- **定义**：一种根据关键码值（Key Value）直接进行访问的数据结构。
- **常见哈希函数**：将关键码映射到数组索引的函数。
- **处理冲突的方法**：如链地址法、开放地址法。

## 13. **字符串算法（String Algorithms）**

- **字符串匹配算法**：如 KMP 算法、Boyer-Moore 算法。
- **字符串哈希**：将字符串映射为整数以便快速比较。
