# React 的调和算法

React 的调和算法（Reconciliation）是其核心机制，用于更新 UI，并确保性能的高效性。为了深入了解调和算法，重要的是弄清楚 **什么时候** React 进行 diff 计算，**什么时候**触发渲染，以及它们的具体**原理**。

## 一、调和算法的核心步骤

调和算法的核心目标是高效地对比两棵虚拟 DOM 树，找到变化的部分并更新真实 DOM。这个过程分为两个主要阶段：

1. **Diff 阶段（Render Phase）**：计算变化（非阻塞的，可以被打断）。
2. **Commit 阶段（Commit Phase）**：将变化应用到真实 DOM（同步，不能被打断）。

## 二、**什么时候进行 Diff 计算（Render Phase）？**

当以下情况发生时，React 触发调和算法，进行虚拟 DOM 的 diff 计算：

- **组件的状态（state）更新**：`useState`, `setState` 触发更新。
- **组件的属性（props）发生变化**：父组件重新渲染并传递新的 `props`。
- **强制更新**：使用 `forceUpdate()` 强制组件更新。

当 React 检测到这些变化时，会先创建新的虚拟 DOM 树，然后与旧的虚拟 DOM 树进行对比，这就是调和算法工作的开始。

### Diff 算法（调和）的工作原理：

- **同层比较**：React 只会比较同一层级的元素，跨层级的元素不会被比较。
- **Key 的作用**：在处理列表时，React 使用 `key` 属性来唯一标识列表项。它通过 `key` 来跟踪元素的顺序，确保最小化 DOM 操作。如果 `key` 发生变化，React 会将原来的元素移除并创建新的元素。
- **元素类型判断**：如果新旧虚拟 DOM 的元素类型相同（例如 `<div>` 对比 `<div>`），React 会保留该 DOM 元素，只更新属性。否则，它会销毁旧节点并创建新节点。

### Diff 的过程：

- **浅比较属性**：React 逐个比较新旧虚拟 DOM 元素的属性。如果属性发生变化，则更新这些属性。
- **递归比较子元素**：如果某个 DOM 元素包含子元素，React 会递归地执行相同的比较过程。

### 计算可以被打断：

调和算法的计算属于 Render Phase，React 可以在这个过程中打断计算，优先处理高优先级任务（比如用户输入、动画等）。这部分依赖 React 的 **Fiber 架构**，Fiber 允许 React 在渲染过程中暂停或丢弃低优先级的更新。

## 三、 **什么时候进行渲染（Commit Phase）？**

一旦调和算法完成了 Diff 计算并确定了哪些部分需要更新，React 进入 **Commit 阶段**，在这个阶段会实际将变化应用到真实的 DOM 中。

- **什么时候触发渲染？**

  - **在 Diff 阶段完成后**：当 React 完成了所有变化的计算，它会进入 Commit Phase，将计算出的变化应用到真实 DOM 中。这部分过程不能被打断。
  - **通过 DOM 操作更新 UI**：React 会将变化后的虚拟 DOM 同步到真实 DOM 中。这是唯一直接修改真实 DOM 的阶段。

- **DOM 更新过程：**
  1. **生命周期钩子执行**：在 Commit Phase，React 执行某些生命周期钩子（例如 `componentDidMount`, `componentDidUpdate` 等，或 `useEffect` 的回调函数）。
  2. **更新 DOM 元素**：React 应用从 diff 结果中得到的最小化更新到实际的 DOM 中。比如，更新属性、替换节点、添加或删除子节点。
  3. **调用动画或其他副作用**：此时，React 可以执行与真实 DOM 相关的副作用操作，如触发动画或事件监听器。

## 四、 **具体的调和算法原理**

调和算法的主要任务是找出新旧虚拟 DOM 树之间的最小差异，并尽可能地优化 DOM 操作。其核心思想有两点：

- **树的分层比较（同层比较）**
- **key 的优化使用**

### （1）分层比较

React 假设两个不同类型的节点会产生完全不同的树，因此不会在不同类型的节点之间进行深度对比。例如：

```jsx
<div> vs <span>
```

React 不会再深入比较这些节点的子节点，而是直接移除 `div`，重新创建 `span` 及其子元素。这种同层级比较的假设大大简化了比较过程。

### （2）Key 的作用

React 处理列表时，`key` 是优化性能的关键。React 会使用 `key` 来唯一标识每一个元素。如果列表中的 `key` 没有变化，React 会复用元素并仅更新必要的部分；如果 `key` 变化，React 会删除旧的元素并创建新的元素。

### （3）Diff 算法的步骤

1. **元素类型相同**：如果两个元素类型相同（例如 `<div>` 对比 `<div>`），React 会保留原来的 DOM 节点，并只更新其属性。
2. **元素类型不同**：如果类型不同（例如 `<div>` 对比 `<span>`），React 会销毁旧的 DOM 节点，并创建新的节点。
3. **子节点的比较**：React 递归地比较子节点，应用同样的规则。
4. **Key 的比较**：当子节点是列表时，React 使用 `key` 来区分不同的子节点。它通过 `key` 来判断元素是否被移动、删除或新增。

### React Fiber 的引入

React Fiber 是 React 16 引入的底层机制，它的主要目的是使调和过程更加灵活，特别是在渲染大型或复杂的组件树时，允许对渲染任务进行拆分和中断。Fiber 实现了“增量渲染”，使 React 可以更好地控制更新过程，确保在性能和响应性之间取得平衡。

Fiber 架构的两个阶段：

1. **Render Phase（可以被打断）**：这就是 Diff 计算的阶段。React 会为每个组件创建 Fiber 节点，并递归地计算哪些组件需要更新。这一阶段可以在必要时暂停。
2. **Commit Phase（不能被打断）**：React 将所有更新同步到 DOM 上。这一阶段的操作是同步的，因为一旦开始修改 DOM，React 希望尽快完成整个更新过程，以确保界面的一致性。

## 五、 **React 的调和机制优化点**

- **按需更新**：React 只更新需要变化的部分，不会重新渲染整个页面。
- **批处理更新**：React 可以将多个状态更新批量处理，从而避免多次无意义的渲染。
- **异步渲染**：React Fiber 允许 React 进行异步渲染，确保界面在复杂场景下的流畅性。

## 六、总结

- **Diff 阶段**：当状态或属性变化时，React 使用调和算法对新旧虚拟 DOM 树进行对比，找出需要更新的部分。这一阶段是异步的、可以被打断的，通过 Fiber 架构的支持，React 能够对任务进行优先级排序并拆分渲染工作。
- **Commit 阶段**：Diff 计算完成后，React 将变化同步到真实 DOM 上。这一阶段是同步的，不能被打断。

调和算法和 Fiber 架构结合，使得 React 在更新界面时能够尽量避免不必要的操作，保证性能的同时，也能优先响应用户的高优先级交互。这是 React 能够在复杂 UI 中保持高效更新的根本原因。
