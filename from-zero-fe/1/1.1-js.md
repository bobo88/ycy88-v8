# JS

::: tip 认知 7 问：JS

1. **这是什么？——了解定义和基本特征**
   - **JavaScript 是什么？**
     - JavaScript 是一种广泛应用于网页开发的编程语言，主要用于前端开发，能够在浏览器中实现动态效果、用户交互、数据处理等功能。它是一种高层次的解释型语言，支持面向对象、函数式编程等多种编程范式。
2. **它有什么用？——探讨用途、功能和价值**

   - **JavaScript 的用途是什么？**
     - JavaScript 主要用于网页的前端开发，可以动态更新页面内容，响应用户的输入，并与后台服务器进行数据交换。它使网页具备动态特性，如表单验证、交互动画、异步请求等。
     - 除了前端开发，Node.js 使 JavaScript 可以在服务器端运行，从而实现全栈开发。

3. **为什么需要它？——理解背景、动机和需求**
   - **为什么需要 JavaScript 而不只用 HTML 和 CSS？**
     - HTML 和 CSS 主要用于网页的结构和样式，但它们是静态的，不具备处理交互和动态内容的能力。JavaScript 通过提供动态和交互功能，让网页能够响应用户输入、更新内容、进行异步通信等，提升用户体验。
4. **它的核心原理是什么？——了解工作机制和理论基础**
   - **JavaScript 是如何工作的？**
     - JavaScript 代码在浏览器中由 JavaScript 引擎（如 V8 引擎）解释并执行。执行时，JavaScript 引擎会把代码解析成 AST（抽象语法树），然后执行对应的操作。JavaScript 还使用事件循环机制来处理异步操作，这允许 JavaScript 在等待某些操作时不阻塞程序执行。
5. **它有哪些优缺点？——分析优势与不足**
   - **JavaScript 的优缺点是什么？**
     - **优点**：
       - **跨平台性**：可以在不同操作系统和设备上运行，尤其是在浏览器中。
       - **动态性**：能够快速响应用户交互，更新页面内容，支持异步操作等。
       - **全栈开发**：通过 Node.js，JavaScript 不仅可以做前端开发，还能做后端开发。
     - **缺点**：
       - **单线程**：JavaScript 默认是单线程的，可能会导致处理复杂计算时出现性能瓶颈。
       - **浏览器兼容性问题**：不同浏览器对 JavaScript 的支持有所不同，可能会导致不同的行为表现。
6. **在哪些情况下使用最合适？——适用场景和最佳实践**

   - **JavaScript 最适合在哪些场景下使用？**
     - **前端开发**：JavaScript 是前端开发的核心语言，可以用来创建交互式网页、动态内容和用户界面。
     - **单页应用（SPA）**：利用框架（如 React、Vue、Angular）和 JavaScript，可以开发复杂的单页应用，提供更流畅的用户体验。
     - **服务器端开发**：通过 Node.js，JavaScript 可以用于处理请求、操作数据库等后端开发任务，实现全栈开发。
     - **异步操作和事件驱动**：JavaScript 的事件循环和异步机制使其非常适合处理用户交互、网络请求和文件操作等场景。

7. **未来的发展方向是什么？——展望潜力与改进空间**
   - **JavaScript 的未来发展方向是什么？**
     - **增强性能**：随着技术的进步，JavaScript 引擎和 V8 引擎等正在不断优化执行效率，减少内存占用，提升速度。
     - **WebAssembly（Wasm）**：WebAssembly 使得可以在浏览器中执行其他语言（如 C、C++）编写的代码，未来 JavaScript 可能与 WebAssembly 深度结合，实现更高效的网页应用。
     - **更加现代的功能**：随着语言本身的演进，JavaScript 将继续加强对函数式编程、类型检查（如 TypeScript）、模块化等现代开发理念的支持。
     - **多线程和并发**：JavaScript 的 Web Worker API 和异步编程机制让开发者能够以更高效的方式处理多线程任务，未来可能有更多原生支持并发操作的特性。

:::

## 1. **基础概念**

- **数据类型**

  - 基本数据类型（Primitive Types）：`undefined`, `null`, `boolean`, `number`, `string`, `symbol` (ES6)
  - 引用数据类型（Reference Types）：`Object`, `Array`, `Function`

    ::: tip 1.1.1 JavaScript 中的常见数据类型总结

    - **基本数据类型**：undefined, null, boolean, number, string, symbol, bigint
    - **引用数据类型**：Object, Array, Function
    - **特殊值**：NaN, Infinity, -Infinity

    :::

    ::: tip 1.1.2 为什么要区分不同的数据类型？

    - **内存管理**：基本数据类型通常存储在栈中，操作快速而简洁；引用数据类型存储在堆中，可以共享数据但操作相对复杂。
    - **性能优化**：基本数据类型是值传递，复制代价小，效率高；引用数据类型是引用传递，允许多个变量共享数据，内存开销较大，但更灵活。
    - **程序逻辑清晰**：通过区分基本数据类型和引用数据类型，开发者可以更直观地理解和操作数据，避免不必要的错误。

    :::

    ::: tip 1.1.3 值传递和引用传递的区别？

    JavaScript 中有两种传递机制：值传递和引用传递，这两种机制与数据类型的行为息息相关。

    - **值传递**：在基本数据类型中，当一个值被赋给另一个变量时，实际上是复制了该值。修改副本不会影响原始值。
    - **引用传递**：在引用数据类型中，传递的是对象的引用（内存地址）。多个变量可能指向同一内存地址，修改其中一个变量的值会影响到其他引用同一对象的变量。
    - **相关问题**：
      - <span style="color:#f00">为什么基本数据类型是值传递，而引用数据类型是引用传递？</span>
        - 基本数据类型是值传递，因为它们直接存储实际的值，而引用数据类型是引用传递，因为它们存储的是对象的内存地址，多个变量可以指向同一个对象。
      - <span style="color:#f00">引用传递可能导致的副作用如何避免？（如：对象共享和修改的问题）</span>
        - 可以通过创建对象的副本（深拷贝或浅拷贝）来避免修改共享引用数据带来的副作用。

    :::

    ::: tip 1.1.4 值传递和引用传递的区别？

    JavaScript 中的 **类型强制** 机制可能会导致一些隐式的类型转换，影响数据类型的行为。例如，在使用 + 操作符时，number 类型和 string 类型会被强制转换为字符串相加。

    - **相关问题**：
      - <span style="color:#f00">为什么 JavaScript 需要进行类型转换？如何处理隐式类型转换？</span>
        - JavaScript 需要进行类型转换是因为它是一种弱类型（loosely-typed）语言，不同类型的数据可以在运算中自动转换，以保证操作能够执行和满足多种场景的需求。
        - 隐式类型转换通常由 JavaScript 引擎根据上下文自动进行，开发者需要理解不同类型之间的转换规则，特别是当不同数据类型参与运算时。例如，+ 运算符会将非字符串类型转换为字符串，而其他算术运算符则会将字符串转换为数字。要小心处理这些自动转换，确保操作符合预期。
      - <span style="color:#f00">什么是类型强制？如何避免出现隐式类型转换带来的错误？</span>
        - 类型强制（Type Coercion）是 JavaScript 中的一种机制，当运算符或函数期望一个特定的数据类型时，JavaScript 会自动将其他类型的值转换为所期望的类型，这种转换分为隐式类型强制和显式类型强制。
        - 为了避免隐式类型转换带来的错误，可以通过以下方式：
          - 使用严格相等（===） 代替非严格相等（==），避免自动类型转换带来的问题。
          - 显式类型转换，即在进行运算或比较时，明确地将数据转换为所期望的类型，比如使用 String(), Number(), Boolean() 等进行显式转换。
          - 谨慎使用类型不明确的运算符，尤其是在比较和字符串拼接时，明确了解不同类型的数据如何相互转换。

    :::

    ::: tip 1.1.5 原始类型 vs. 包装类型
    JavaScript 中有 **原始类型** 和 **包装类型** 的概念。包装类型是原始类型的对象包装器（如 String, Number, Boolean）。它们允许你在原始类型上调用方法和属性。

    - **原始类型**：例如 string, number, boolean 等。
    - **包装类型**：如 new String(), new Number(), new Boolean()，这些对象提供了额外的方法和属性，但它们和原始类型有所不同。
    - **相关问题**：
      - <span style="color:#f00">为什么 JavaScript 有包装类型？它们和原始类型有何不同？</span>
        - JavaScript 通过包装类型为原始类型提供对象方法和属性，弥补原始类型无法直接调用方法的限制。
        - 原始类型是不可变的，直接存储值；包装类型是对象，提供原始类型的封装，允许调用方法和访问属性。
      - <span style="color:#f00">JavaScript 中的自动类型转换（隐式转换）是如何在包装类型和原始类型之间工作的？</span>
        - 当原始类型值需要访问方法时，JavaScript 会临时将其转换为包装对象，操作完成后再返回原始值。
        - 包装类型在调用方法时会临时创建一个对象，调用结束后对象会被销毁，这个过程称为“自动装箱”和“自动拆箱”。

    :::

    ::: tip 1.1.6 符号（Symbol）类型
    Symbol 是 JavaScript 中 ES6 引入的 基本数据类型，它的目的是为对象的属性名提供唯一性。每一个 Symbol 都是唯一的，因此它可以用于创建“私有”属性，防止属性名冲突。

    - **相关问题**：
      - <span style="color:#f00">Symbol 与其他数据类型有什么区别？为什么它是唯一的？</span>
        - Symbol 是一种原始数据类型，表示唯一的标识符，与其他数据类型的值不同，Symbol 值不可变且不可通过 new 操作符创建。
        - 每个 Symbol 值都是唯一的，即使使用相同的描述符创建多个 Symbol，它们也不会相等。Symbol 的唯一性来源于其内建的机制，每次创建一个 Symbol 时，它会生成一个全局唯一的标识符，即使使用相同的描述符，也会返回不同的 Symbol 值。
      - <span style="color:#f00">在实际开发中如何使用 Symbol 来避免属性冲突或实现私有成员？</span>
        - 可以使用 Symbol 作为对象属性的键，以避免属性冲突，因为 Symbol 总是唯一的，且不会被外部访问到，从而能模拟私有成员。

    :::

    ::: tip 1.1.7 类型推断与动态类型语言

    JavaScript 是 动态类型语言，这意味着变量的类型在运行时才会确定，开发者不需要显式声明类型。这带来了灵活性，但也增加了出错的可能性。

    - **相关问题**：
      - <span style="color:#f00">为什么 JavaScript 是动态类型语言？与静态类型语言相比有哪些优缺点？</span>
        - JavaScript 是动态类型语言，因为变量的类型是在运行时确定的，而不是在编写代码时显式声明的。变量可以在不同时间持有不同类型的值，类型检查在程序执行时进行。
        - **优点**：
          - 更高的灵活性：无需提前声明类型，代码更简洁、易于编写。
          - 开发速度较快：可以在运行时动态处理不同类型的数据。
        - **缺点**：
          - 运行时错误：由于类型在运行时决定，可能导致类型错误在程序执行时才发现。
          - 可维护性差：在大型项目中，动态类型可能会增加调试和修改的难度。
      - <span style="color:#f00">如何通过静态类型检查工具（如 TypeScript）来提升代码的可维护性？</span>
        - 通过使用静态类型检查工具，如 TypeScript，开发者可以在编写代码时明确指定变量类型，提前捕获类型错误，增加代码的可读性、可预测性和可维护性，尤其在大型项目中能有效减少错误和提高代码的可靠性。

    :::

    ::: tip 1.1.8 类型兼容性和类型保护

    在 JavaScript 中，类型兼容性和类型保护是处理不同类型之间的转换、赋值和操作时需要考虑的一个方面。

    - **类型兼容性**：JavaScript 在进行类型转换时，会自动检查值是否兼容。
    - **类型保护**：通过条件判断（如 typeof、instanceof）来确保数据的类型是预期的。
    - **相关问题**：
      - <span style="color:#f00">类型保护如何确保数据类型的安全性？如何避免类型错误？</span>
        - 类型保护通过明确检查和限制值的类型，使得在运行时仅允许特定类型的数据通过，从而避免类型不匹配或不符合预期的数据操作。例如，使用 typeof 或 instanceof 来确保变量是某种特定类型，从而提供类型安全。
        - **如何避免类型错误？**
          - **类型检查**：使用 typeof, instanceof 等运算符显式检查数据类型，确保其符合预期。
          - **TypeScript 类型注解**：通过静态类型检查工具（如 TypeScript）在编译时捕获类型错误，避免运行时出错。
          - **防御性编程**：使用条件判断和默认值等方法，确保操作之前数据符合预期的类型和格式。
          - **使用类型守卫（Type Guards）**：在代码中使用类型守卫（例如类型断言或类型保护函数），确保变量在特定范围内是正确的类型，从而避免意外的类型错误。

    :::

- **变量声明与作用域**
  - `var`, `let`, `const` 的区别
  - **作用域**：全局作用域、函数作用域、块级作用域
    - **var：属于 函数作用域**，在声明前访问会得到 undefined，而且会存在变量提升（Hoisting），即变量声明被提升到函数/全局作用域的顶部。
    - **let 和 const：属于 块级作用域**，只在块级代码块内有效（如 if、for 等），不会发生变量提升。let 允许变量重新赋值，而 const 是常量，声明时必须初始化，且一旦赋值后不能修改。
  - **作用域链和闭包**
    - **作用域链**：当访问一个变量时，JavaScript 会根据作用域链的规则从当前作用域开始查找，逐级向上查找，直到找到该变量或到达全局作用域。如果找不到，抛出 ReferenceError。
    - **闭包**：闭包是指函数在访问其外部作用域的变量时，形成的一种持久的作用域链。即使外部函数执行完毕，内部函数依然能访问外部作用域的变量。
- **类型转换与判断**

  - 强制类型转换（如 `Number()`, `String()`, `Boolean()`）
    - 强制类型转换通过内置函数明确地将一个值转换为特定的类型，帮助处理不同类型数据的转换需求。
  - 类型判断：`typeof`, `instanceof`, `Object.prototype.toString.call()`
    - 类型判断使用不同的操作符和方法（typeof, instanceof, Object.prototype.toString.call()）来判断数据的类型，以确保在代码中进行正确的类型处理和避免类型错误。

- **基本操作**
  - 算术、比较、逻辑运算符
  - 赋值与解构赋值
    - 解构赋值允许从数组或对象中提取值并将其赋给变量，提供了一种简洁的赋值方式。对于数组，按位置提取值；对于对象，按键提取值。
  - 字符串操作、数组操作（包括常用方法 `map()`, `filter()`, `reduce()` 等）
    - **字符串常用方法**：`charAt()`, `concat()`, `indexOf()`, `slice()`, `substring()`, `toUpperCase()`, `toLowerCase()`, `trim()`, `split()`, `replace()` 等
    - **数组常用方法**：`map()`, `filter()`, `reduce()`, `forEach()`, `push()`, `pop()`, `shift()`, `unshift()`, `find()`, `sort()`, `concat()`

## 2. **核心概念**

- **闭包 (Closure)**

  - 闭包的定义和应用：如何通过闭包访问外部函数的变量
    - **定义：**
      - 闭包是 JavaScript 中一个重要的概念，它是由函数及其函数内部引用的外部变量组成的一个结构。
      - **本质**：闭包允许内部函数访问外部函数的作用域，即使外部函数已经执行完毕并返回，内部函数依然可以访问外部函数的变量。
      - 闭包的核心特点是 **函数能够记住并访问定义时的作用域**。
    - **应用：**
      - **封装私有变量**：闭包可以用来创建私有变量，这些变量只能在闭包内部访问，从而实现数据的封装和隐藏。
      - **模拟私有方法**：闭包可以用来模拟私有方法，使得这些方法只能在闭包内部调用，外部无法直接访问。
      - **实现模块模式**：闭包可以用来实现模块模式，将相关的数据和函数封装在一个闭包中，从而创建一个独立的模块。
      - **实现回调函数**：闭包可以用来实现回调函数，使得回调函数能够访问外部函数的变量。
  - 闭包的性能问题（内存泄漏）
    - **本质**：闭包会保持对外部函数变量的引用，因此如果闭包引用的变量持续存在，会导致这些变量在不再需要时无法被垃圾回收，从而导致内存泄漏。
    - 内存泄漏通常发生在以下情况下：
      - 闭包引用了大量数据并且长时间存在（例如，长时间未被销毁的 DOM 元素引用）。
      - 闭包被多次创建并且没有及时清除。
    - 如何避免内存泄漏：
      - **及时清除不再需要的闭包引用**：通过将闭包置为 null 或通过垃圾回收机制释放不再使用的闭包引用。
      - **避免闭包长期持有大量内存数据**：减少闭包中持有大量数据的情况，尤其是引用 DOM 元素时，应谨慎避免不必要的长时间引用。
      - **使用 WeakMap/WeakSet**：使用弱引用数据结构（例如 WeakMap 或 WeakSet）来避免对大对象的强引用，从而减少内存泄漏风险。

- **原型与原型链**

  - 原型链的工作原理：如何通过原型链查找属性
  - `Object.prototype` 和构造函数的原型
  - `prototype` 和 `__proto__` 的关系

  ::: tip 2.2.1 原型链和继承
  原型链（Prototype Chain） 是 JavaScript 中继承机制的核心，它允许对象通过原型链访问父对象的属性和方法。所有的对象都继承自 Object 类型，它的原型就是 null。

  - **原型链的形成**：每个对象都有一个隐式的 [[Prototype]] 属性，指向它的构造函数的 prototype 对象。对象属性查找是通过原型链逐层向上查找的。
  - **相关问题**：
    - <span style="color:#f00">原型链是如何工作的？它与数据类型的继承关系如何结合？</span>
      - 原型链是 JavaScript 中对象属性和方法查找的一种机制，当访问一个对象的属性或方法时，若该对象没有该属性，则会查找该对象的原型对象，依此类推，直到找到该属性或到达原型链的顶端。
      - 原型链实现了对象之间的继承关系，子对象可以继承父对象的属性和方法，通过原型链可以动态共享父对象的功能和数据。
    - <span style="color:#f00">为什么使用原型链来进行继承，而不是直接使用类的继承？</span>
      - JavaScript 最初是基于原型的继承模型而设计的，原型链继承灵活且实现简单，在 ES6 引入类（class）语法后，类的继承本质上也是基于原型链机制的。

  :::
  ::: tip 2.2.2 深拷贝与浅拷贝
  在处理引用数据类型时，通常需要考虑 **深拷贝** 和 **浅拷贝** 的问题。浅拷贝只是复制对象的引用，而深拷贝会递归地复制对象的所有属性和子对象。

  - **浅拷贝**：只复制对象的引用。
  - **深拷贝**：递归地复制对象的所有属性，甚至包括嵌套对象。
  - **相关问题**：
    - <span style="color:#f00">深拷贝和浅拷贝的实现原理是什么？如何在 JavaScript 中手动实现它们？</span>
      - **浅拷贝**：创建一个新对象，新对象的属性是对原对象属性的引用，若原属性是基本数据类型，则复制值，若原属性是引用数据类型，则复制引用。
      - **深拷贝**：创建一个新对象，新对象的所有属性（包括嵌套的对象）都会递归地进行拷贝，确保没有任何引用共享。
      - **浅拷贝**：可以使用 `Object.assign()` 方法或展开运算符（`...`）来实现浅拷贝。
      - **深拷贝**：使用递归来手动拷贝所有嵌套对象，也可以使用 `JSON.parse(JSON.stringify(obj))` 方法来实现深拷贝，但这种方法无法处理函数、`undefined`、`Symbol` 等特殊数据类型。
    - <span style="color:#f00">为什么浅拷贝可能引起问题（如引用共享问题）？</span>
      - 浅拷贝仅复制对象的引用，因此修改新对象的嵌套对象会影响原对象，反之亦然，这会导致不期望的副作用，特别是当多个对象共享同一个引用时。

  :::

- **事件循环 (Event Loop)**
  - 同步与异步的区别
  - JavaScript 的执行栈与事件队列
  - 宏任务与微任务的执行顺序
  - 事件循环的异步操作（如 setTimeout, Promise 等）

## 3. **面向对象编程 (OOP)**

- **对象和类**

  - 对象字面量和构造函数
  - `this` 的指向与作用
  - 类（ES6+）：`class`, `constructor`, `extends`, `super`
  - 静态方法和实例方法

- **继承与多态**

  - 原型链继承与类继承
  - `Object.create()` 和继承关系
  - 方法重写与多态

- **封装与模块化**
  - 私有变量和方法
  - 闭包与封装设计模式

## 4. **现代 JavaScript 特性 (ES6+)**

- **ES6 语法特性**

  - `let`, `const` 和块级作用域
  - 解构赋值：数组解构、对象解构
  - 模板字符串（Template Literals）
  - 箭头函数（Arrow Functions）
  - 默认参数、剩余参数（Rest Parameters）
  - 扩展运算符（Spread Operator）
  - 类与继承（Class & Inheritance）

- **模块化**
  - 模块的引入与导出：`import` 和 `export`
  - 动态导入：`import()`
  - CommonJS 和 ES Module 比较

## 5. **异步编程**

- **回调函数 (Callback)**

  - 基本概念与应用：回调地狱
  - 解决回调地狱的技巧

- **Promise**

  - `Promise` 的基本概念和状态：`pending`, `fulfilled`, `rejected`
  - 链式调用：`then()`, `catch()`
  - 异常处理：`catch()` 与错误传递
  - `Promise.all()`, `Promise.race()`

- **Async/Await**
  - `async` 和 `await` 的语法
  - 异步函数的返回值：`Promise`
  - 错误处理：`try...catch` 和 `await`
  - `await` 的执行时机和阻塞行为

## 6. **高级概念**

- **函数式编程 (Functional Programming)**

  - 高阶函数：函数作为参数和返回值
  - 函数组合与柯里化（Currying）
  - 不可变性（Immutability）与纯函数（Pure Function）
  - `map()`, `filter()`, `reduce()` 的应用

- **异步模式与设计模式**

  - 发布订阅模式（Pub/Sub）
  - 观察者模式（Observer）
  - 中介者模式（Mediator）
  - 状态模式（State Pattern）

- **内存管理与性能优化**

  - 垃圾回收机制（GC）
  - 闭包与内存泄漏
  - 事件委托与优化 DOM 操作

  ::: tip 垃圾回收（Garbage Collection）

  JavaScript 的内存管理和清理是通过 垃圾回收机制 来实现的。垃圾回收负责清除不再被引用的数据，以避免内存泄漏。两种常见的垃圾回收策略是：

  - 引用计数（Reference Counting）：跟踪每个对象被引用的次数，当引用次数为 0 时，对象可以被回收。
  - 标记-清除（Mark-and-Sweep）：遍历所有的对象，将不再引用的对象标记为“可回收”，然后清除它们。

  - **相关问题：**
    - <span style="color:#f00">JavaScript 是如何管理内存和执行垃圾回收的？</span>
    - <span style="color:#f00">垃圾回收与引用数据类型的关系是什么？为什么引用数据类型的生命周期更难管理？</span>

  :::

  ::: tip 栈和堆的内存管理

  **栈和堆** 是 JavaScript 存储数据的两种不同方式，基本数据类型和引用数据类型的存储方式分别对应这两者。

  - **栈（Stack）**：用于存储基本数据类型（如 number, boolean, undefined 等）和函数调用的上下文（执行环境）。栈的特点是：快速、内存使用高效、遵循 LIFO（后进先出）原则。数据的生命周期通常较短，生命周期由函数调用的栈帧决定。
  - **堆（Heap）**：用于存储引用数据类型（如 Object, Array, Function 等）。堆内存分配较慢，但能够存储更复杂的数据结构。引用数据类型的生命周期通常由引用计数（或者垃圾回收机制）管理。

  - **相关问题：**
    - <span style="color:#f00">为什么栈中的数据访问速度比堆中的数据更快？</span>
    - <span style="color:#f00">为什么引用数据类型存储在堆中而不是栈中？堆中内存的管理和回收是如何进行的？</span>

  :::

## 7. **浏览器与 DOM 操作**

- **DOM 操作**

  - 选择器：`getElementById()`, `querySelector()` 等
  - DOM 元素创建与修改：`createElement()`, `innerHTML`, `appendChild()`, `removeChild()`
  - 事件处理：`addEventListener()`, 事件冒泡与捕获

- **浏览器特性**
  - 事件循环与异步请求：`setTimeout()`, `setInterval()`, `requestAnimationFrame()`
  - 本地存储：`localStorage`, `sessionStorage`, `cookies`
  - Fetch API 与 XMLHttpRequest

## 8. **工具与框架**

- **调试与测试**

  - 调试工具：浏览器控制台，调试语句（`console.log()`, `console.error()`）
  - 单元测试：`Jest`, `Mocha`, `Chai` 等测试框架
  - 自动化测试和集成测试

- **构建工具与模块打包**
  - `Webpack`, `Parcel`, `Rollup` 等构建工具
  - Babel 转译与 Polyfill
  - NPM 与 Yarn 包管理工具
