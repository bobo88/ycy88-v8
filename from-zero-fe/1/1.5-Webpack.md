# Webpack

> 专题版块详见 [Webpack 专题](/tools/fe/2_Webpack)。

| 特性                  | **Parcel**                                                                | **Webpack**                                                              | **Vite**                                                                              | **Rollup**                                                                         | **Gulp**                                                                                  |
| --------------------- | ------------------------------------------------------------------------- | ------------------------------------------------------------------------ | ------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **运行机制**          | - 零配置，自动推导项目构建配置                                            | - 基于配置的工具，开发者需要手动编写配置文件                             | - 使用原生 ES 模块（ESM）实现开发时的按需构建，生产构建时使用 Rollup                  | - 专注于 JavaScript 和 ES6 模块的打包，主要优化打包体积，生成高效的代码            | - 基于流的构建工具，任务驱动式构建，适合处理复杂的构建任务，如图片压缩、文件复制等        |
| **模块化构建**        | - 自动生成模块依赖图，通过分析文件的 `import` 和 `require` 来构建依赖关系 | - 通过 `require`/`import` 分析模块依赖，并基于此生成模块依赖图           | - 采用原生 ES 模块（ESM）方式，按需加载模块，开发阶段不打包，生产阶段使用 Rollup 打包 | - 强调模块化打包，适用于 JavaScript 和 ES6 模块，提供 Tree Shaking、代码分割等优化 | - 通过任务流来管理构建流程，通常与其他工具如 Babel、Sass 配合使用，处理任务而非模块依赖   |
| **构建速度**          | - 快速，支持增量构建，自动缓存，适合小到中型项目                          | - 需要手动配置，构建速度较慢，特别是处理大型项目时                       | - 极快，采用按需构建和原生 ES 模块，开发时构建速度极快，生产构建使用 Rollup 优化性能  | - 主要优化 JavaScript 的打包体积，支持 Tree Shaking 和代码分割，构建速度较快       | - 构建速度较慢，因为它是任务流系统，处理复杂的任务时会有一定的延迟，适合处理各种任务流    |
| **热模块替换（HMR）** | - 内置支持 HMR，修改代码后自动更新页面，无需刷新页面                      | - 支持 HMR，但需要配置和插件支持，配置较为复杂                           | - 高效的 HMR，原生支持 ES 模块，只有更改的部分会重新加载，更新速度快                  | - 不直接支持 HMR，通常与开发服务器或其他工具结合使用                               | - 不直接支持 HMR，适合文件和资源的任务自动化处理，通常与 Webpack、Vite 配合使用           |
| **插件系统**          | - 插件生态较小，功能相对简单                                              | - 插件生态庞大，几乎可以扩展任何功能，支持非常复杂的定制                 | - 插件支持较好，但没有 Webpack 那么庞大，主要专注于前端构建优化和加速                 | - 插件系统简洁高效，适用于小到中型项目，主要专注于构建时的优化和体积压缩           | - 插件丰富，任务流驱动的工作流，适用于自动化任务，如压缩、转码、文件合并等                |
| **Tree Shaking**      | - 支持，通过分析模块依赖关系去除无用代码                                  | - 内置 Tree Shaking 功能，有效去除无用代码，减小打包体积                 | - 使用 Rollup 支持 Tree Shaking，减小打包后的体积                                     | - 原生支持 Tree Shaking，通过静态分析去除无用代码，生成小体积的代码                | - 无原生 Tree Shaking 支持，通常需要与其他工具结合使用进行模块优化                        |
| **代码分割**          | - 支持代码分割，通过动态导入（dynamic import）分割代码                    | - 强大的代码分割功能，支持异步加载，按需加载，优化资源加载               | - 支持按需加载和代码分割，生产构建时通过 Rollup 实现                                  | - 支持按需加载和代码分割，优化打包过程中的资源分配，适合大型项目                   | - 不直接支持代码分割，通常与 Webpack 配合使用，通过任务来实现代码的拆分和管理             |
| **配置复杂度**        | - 零配置，开箱即用，适合快速开发和小型项目                                | - 配置复杂，需要开发者编写详细的配置，灵活性极高                         | - 零配置，简单易用，适合中小型项目，但对于高度定制的需求，可能不如 Webpack 灵活       | - 配置简单，支持较好的模块化构建，但对于大型项目的定制性较弱                       | - 配置相对简单，适合任务驱动的构建，复杂的任务需要通过自定义任务来配置                    |
| **优点**              | - 零配置，简单易用                                                        | - 高度可定制，功能强大，支持复杂的构建需求                               | - 启动速度快，极高的开发体验，支持按需构建，生产环境构建速度也很快                    | - 小体积，高效的模块化打包，支持 Tree Shaking 和代码分割，打包后的代码很高效       | - 任务驱动，适合处理复杂的构建任务，灵活且插件支持丰富，可以与其他工具结合使用            |
| **缺点**              | - 插件生态较弱，不适合复杂的项目，无法满足高级功能需求                    | - 配置复杂，学习曲线陡峭，构建速度较慢，尤其是在大型项目中               | - 插件生态相对较小，虽然开发体验很快，但缺少 Webpack 强大的定制化能力                 | - 主要面向 JavaScript，缺少对其他类型资源（如 CSS、图片等）的优化能力              | - 不适合直接处理模块化打包，更多是任务流自动化处理，适合与其他构建工具配合使用            |
| **应用场景**          | - 小到中型项目，快速开发，适合不想花太多时间在配置上的项目                | - 大型项目，复杂需求，需要高度自定义的场景，适合需要优化构建和性能的项目 | - 前端开发，尤其适合 Vue、React 等现代框架的开发，开发体验非常好，生产环境也很高效    | - 适用于 JavaScript 的高效打包，生成的小体积代码适合部署到生产环境                 | - 适用于任务流自动化的处理，如图片压缩、CSS 处理、文件复制等，与 Webpack、Parcel 配合使用 |
| **社区和支持**        | - 社区较小，支持和文档相对不足                                            | - 社区庞大，文档完善，广泛应用于各类大型项目中                           | - 社区逐渐壮大，文档完善，主要用于现代前端开发，特别是 Vue、React 和 Svelte 项目      | - 社区较小，主要聚焦于优化 JavaScript 构建的工具，适合中小型项目                   | - 社区庞大，文档丰富，广泛应用于前端和自动化构建任务领域，适合各种任务管理需求            |

### 总结：

- **Parcel** 适合快速开发和小型项目，零配置是它的一大优势，适合那些不想配置太多工具的开发者。
- **Webpack** 适合大型项目和复杂构建，具有强大的自定义能力和插件系统，适合需要精细化控制和性能优化的项目。
- **Vite** 专注于现代前端框架的开发体验，利用原生 ES 模块进行按需构建，开发时的速度极快，生产构建也通过 Rollup 优化，适合需要快速开发和高效构建的项目。
- **Rollup** 主要用于 JavaScript 模块的高效打包，支持 Tree Shaking 和代码分割，适合用于生成小体积的生产环境代码。
- **Gulp** 作为一个任务流工具，适用于处理文件、图片、样式等资源的自动化任务，通常与其他打包工具（如 Webpack）配合使用。
